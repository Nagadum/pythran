\documentclass[a4paper]{article}

% lang
\usepackage[utf8]{inputenc}   
\usepackage[T1]{fontenc}      
\usepackage[francais]{babel}  

\usepackage{url}
\usepackage{listings}
\lstset{language=python}

\usepackage{todonotes}
%\usepackage[disable]{todonotes}

%graphics
\graphicspath{{Pictures/}}

\usepackage[a4paper]{geometry}

\title{Extension du langage Pythran pour le module itertools}           
\author{Alan Raynaud}
\date{}                      

\sloppy 

\begin{document}

%Page de garde

\maketitle   

\listoftodos[Liste de ce qui est tout doux]

\clearpage

\section*{Le langage pythran}

\subsection*{Amélioration des performances du python}

Le langage python, populaire des les milieus scientifiques, a
l'inconvénient d'être très peu performant comparé à des langages comme
C ou C++. C'est dans le but de permettre d'écrire des programmes
scientifiques en python qui soient les plus performants possible
qu'est né le projet pythran.

Pythran convertit un code python en C++, pour ensuite le compiler en
un programme natif hautement performant. L'utilisation de pythran ne
nécessite pas de modification du code exsitant, seules quelques
annotations de typage sont à ajouter en début de fichiers. Pythran
peut également permettre de paralléliser le code en utilisant des
annotation openMP, classiquement utilisées en C/C++.

Pythran est principalement destiné à être utilisé pour le calcul
scientifique, et ne supporte qu'une sous-partie de python. Le gain de
performance pour ce type de programme peut par contre atteindre un
facteur 2000.

\subsection*{Pythran et ses concurrents}

Il existe de nombreux outils visant à améliorer les performances de
programmes écrit en python.

Il existe par exemple des bibliothèque de calcul scientifique écrite
en C/C++ et destinée à être utilisée depuis python, comme NumPy.

D'autres approches sont similaires à pythran comme PyPy, Cython ou
Shedskin. Ces derniers supportent une plus grande partie de python que
pythran, mais sont moins performant que pythran pour le calcul
scientifique.


\section*{Le problème des listes inutiles}

\subsection*{Description du problème}

L'un des type les plus souvent manipulé en python est la liste. Il
s'agit d'un ensemble de valeurs rangée en mémoire, auquelles on peut
accéder à n'importe quel moment et dans l'ordre que l'on souhaite.

Or il arrive que l'on utilise une liste pour stocker des valeurs que
l'on ne consultera qu'une fois et dans l'ordre dans laquelle elle sont
stockés. On stock ainsi un ensemble de valeur alors que l'on aurait pu
les produire et les oublier au fur et à mesure. On a donc reservé un
espace mémoire pour stocker la liste entière tandis qu'un espace de la
taille d'une seule valeur aurait suffit.

Des tests montre qu'en plus de consommer inutilement de la mémoire,
cette surallocation d'espace a un coût en performance : une partie non
négligeable du temps de calcul est occupé à allouer/désallouer de la
mémoire.

\subsection*{Le module itertools}

Le langage python fournit un module appelé itertools, qui contient un
certain nombre d'itérateurs. Ces itérateurs sont les équivalent
d'autres opérateurs de python, mais produisent leur valeurs au fur et
à mesure plutôt que de renvoyer une liste de valeur.

Le module itertools est donc une solution en python pour éviter le
problème d'allocation de mémoire inutile. Cette solution présente
cependant l'inconvénient de forcer le développeur python à devoir
gérer lui-même le choix ou non d'utiliser des itérateurs en fonction
de chaque situation. \todo{Dire que contraire à philo python?}

\subsection*{Les autres solutions \todo{Changer titre si pas d'autre}}

Cette problématique est présente depuis longtemps en python. C'est
pour cela que dans python 3, beaucoup d'opérateurs de base se
comportent désormais comme des itérateurs. Le développeur n'a plus à
se poser de question et il y a beaucoup moins de liste inutiles.

Python 3 est cependant incompatible avec les programme écrits en
python 2.7, qui restent la plus grande majorité des programmes écrits
en python. Optimiser un programme python 2.7 en le transformant en
python 3 nécessite donc de nombreuses modifications du code existant.

Il existe un outils nommé 2to3 qui permet d'effectuer automatiquement
cette conversion. Cependant, 2to3 est très conservatif et force la
reconversion en liste de tous les iterateurs introduits dans python
3. En effet, il n'est pas possible de savoir simplement si le
programme d'origine nécessite que le résultat soit bel et bien une
liste.

En résumé, itertools apporte une solution au problème mais augmente la
charge du développeur.

\section*{Solutions apportées}

\subsection*{Implémentation du module itertools}

L'un des premiers objectifs du projet a été de permettre à pythran de
supporter le module itertools. Parmis les itérateurs d'itertools, les
4 suivants ont été implémenté :

\begin{itemize}
  \item imap
  \item izip
  \item ifilter
  \item product
\end{itemize}

Ce sont ces iterateurs qui sont les plus courament utilisés, et ont
permis de poser les bases de l'implémentation d'un itérateur
itertools. Parmis les autres iterateurs, un certain nombre ne sont que
des variantes de ceux-ci, comme ifilterfalse ou iziplongest. Le
développement des iterateurs manquants pourra être fait à l'avenir, en
s'appuyant sur ce qui a été réalisé ici.

La figure suivante illuste le gain de performance obtenu par
utilisation d'un itérateur.

\begin{figure}[h]
  \includegraphics[width=\textwidth]{MapImap}
  \caption{Comparaison entre l'opérateur map et son itérateur équivalent.}
\end{figure}
\todo{Refaire mesure avec la toute derniere version de map/imap}


\subsection*{Optimisations automatique de code}

Comme évoqué précedement, le problème de la solution itertools est
qu'elle oblige le développeur python à choisir explicitement un
itérateurs pour optimiser les performances. C'est pour cela qu'une
grande partie du projet a été dédiée à l'optimisation automatique du
programme initial pour utiliser des itérateurs quand cela est possible
et pertinent.

Les optimisations suivantes ont étée implémentées :

\begin{itemize}
\item Transformation des opérateurs de base en itérateurs. Exemple :
  map->imap
\item Transformation des List Comprehension en iterateurs.
\item Transformation des Generator Expressions en itérateurs.
\end{itemize}

La plupart de ces optimisations se déroulent en deux parties :

\begin{itemize}
\item Un algorithme analyse le peogramme pour détecter les parties
  pouvant bénéficier de l'optimisation.
\item Une transformation applique l'optimisation là où c'est possible.
\end{itemize}

C'est la recherche et le développement d'algorithmes d'analyse qui a
nécessité le plus de temps. Les transformations étant généralement
triviale, comme le remplacement de map par imap.

Comme le montre la figure suivante, les optimisations ont permis un
gain en performance significatifs quand elles sont possible.

\begin{figure}[h]
  \includegraphics[width=\textwidth]{perf_optimization}
  \caption{Gain de performance dû aux optimisations.}
\end{figure}


\section*{Conclusion}

Les optimisations apportées par ce projet permette à pythran
d'améliorer encore plus ses performances sur les cas qui s'y
prêtent. On doit cependant rappeler que cette optimisation ne porte
que sur les temps d'allocation de mémoire non nécessaire. Ces temps
peuvent être très importants dans des programme utilisant de nombreux
parcours de listes, mais ils peuvent être négligeable dans d'autre
type de programme.

Les algorithmes développés pour analyser les cas propices aux
optimisations peuvent cependant être utiles à d'autres outils que
pythran. En particuliers, ils pourraient être utilisés par l'outils
2to3 pour faire de meilleurs choix de conversion. On gagnerait ainsi
en performance simplement en convertissant un programme python 2.7
vers python 3.

\end{document}

